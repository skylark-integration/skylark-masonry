{"version":3,"sources":["skylark-masonry.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-masonry.js","sourcesContent":["define('skylark-masonry/Masonry',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-jquery\"\r\n], function (skylark,jQuery) {\r\n\r\n    'use strict';\r\n\r\n    var console = window.console;\r\n    var noop = function() {};\r\n    var instances = {};\r\n\r\n    // -------------------------- masonryDefinition -------------------------- //\r\n\r\n    // create an Outlayer layout class\r\n    //var Masonry = Outlayer.create('masonry');\r\n\r\n    /**\r\n     * @param {Element, String} element\r\n     * @param {Object} options\r\n     * @constructor\r\n     */\r\n    function Masonry(element, options) {\r\n        var queryElement = getQueryElement(element);\r\n        if (!queryElement) {\r\n            if (console) {\r\n                console.error('Bad element for ' + this.constructor.namespace +\r\n                    ': ' + (queryElement || element));\r\n            }\r\n            return;\r\n        }\r\n        this.element = queryElement;\r\n        // add jQuery\r\n        if (jQuery) {\r\n            this.$element = jQuery(this.element);\r\n        }\r\n\r\n        // options\r\n        this.options = jQuery.extend({}, this.constructor.defaults);\r\n        this.option(options);\r\n\r\n        // add id for Outlayer.getFromElement\r\n        var id = ++GUID;\r\n        this.$element.data(\"outlayerGUID\", id); // expando\r\n        instances[id] = this; // associate via id\r\n\r\n        // kick it off\r\n        this._create();\r\n\r\n        var isInitLayout = this._getOption('initLayout');\r\n        if (isInitLayout) {\r\n            this.layout();\r\n        }\r\n    }\r\n\r\n    // settings are for internal use only\r\n    Masonry.namespace = 'masonry';\r\n    Masonry.Item = function(elem, layout) {\r\n        this.element = elem;\r\n        this.layout = layout;\r\n        this.position = {\r\n            x: 0,\r\n            y: 0\r\n        };\r\n    };\r\n    Masonry.Item.prototype.getSize = function() {\r\n        return this.size = {\r\n            outerWidth: $(this.element).outerWidth(true),\r\n            outerHeight: $(this.element).outerHeight(true)\r\n        };\r\n    };\r\n    Masonry.Item.prototype.goTo = function(x, y) {\r\n        this.position.x = parseInt(x, 10);\r\n        this.position.y = parseInt(y, 10);\r\n        $(this.element).css({\r\n            position: \"absolute\",\r\n            left: this.position.x + \"px\",\r\n            top: this.position.y + \"px\"\r\n        });\r\n    };\r\n    Masonry.Item.prototype.moveTo = function(x, y) {\r\n        //this.goTo(x,y);\r\n        //$(this.element).slideInDown();\r\n        $(this.element).css({\r\n            position: \"absolute\",\r\n        });\r\n        $(this.element).moveto(x, y);\r\n    };\r\n    // default options\r\n    Masonry.defaults = {\r\n        containerStyle: {\r\n            position: 'relative'\r\n        },\r\n        initLayout: true,\r\n        originLeft: true,\r\n        originTop: true,\r\n        resize: true,\r\n        resizeContainer: true,\r\n        // item options\r\n        transitionDuration: '0.4s',\r\n        hiddenStyle: {\r\n            opacity: 0,\r\n            transform: 'scale(0.001)'\r\n        },\r\n        visibleStyle: {\r\n            opacity: 1,\r\n            transform: 'scale(1)'\r\n        }\r\n    };\r\n\r\n    Masonry.compatOptions = {\r\n        // currentName: oldName\r\n        initLayout: 'isInitLayout',\r\n        horizontal: 'isHorizontal',\r\n        layoutInstant: 'isLayoutInstant',\r\n        originLeft: 'isOriginLeft',\r\n        originTop: 'isOriginTop',\r\n        resize: 'isResizeBound',\r\n        resizeContainer: 'isResizingContainer'\r\n    };\r\n\r\n\r\n    // isFitWidth -> fitWidth\r\n    Masonry.compatOptions.fitWidth = 'isFitWidth';\r\n\r\n    Masonry.prototype.getSize = function() {\r\n        this.size = {\r\n            width: $(this.element).width(),\r\n            height: $(this.element).height()\r\n        };\r\n    };\r\n    Masonry.prototype._resetLayout = function() {\r\n        this.getSize();\r\n        this._getMeasurement('columnWidth', 'outerWidth');\r\n        this._getMeasurement('gutter', 'outerWidth');\r\n        this.measureColumns();\r\n\r\n        // reset column Y\r\n        this.colYs = [];\r\n        for (var i = 0; i < this.cols; i++) {\r\n            this.colYs.push(0);\r\n        }\r\n\r\n        this.maxY = 0;\r\n    };\r\n\r\n    Masonry.prototype.measureColumns = function() {\r\n        this.getContainerWidth();\r\n        // if columnWidth is 0, default to outerWidth of first item\r\n        if (!this.columnWidth) {\r\n            var firstItem = this.items[0];\r\n            var firstItemElem = firstItem && firstItem.element;\r\n            // columnWidth fall back to item of first element\r\n            this.columnWidth = firstItem && firstItem.getSize().outerWidth ||\r\n                // if first elem has no width, default to size of container\r\n                this.containerWidth;\r\n        }\r\n\r\n        var columnWidth = this.columnWidth += this.gutter;\r\n\r\n        // calculate columns\r\n        var containerWidth = this.containerWidth + this.gutter;\r\n        var cols = containerWidth / columnWidth;\r\n        // fix rounding errors, typically with gutters\r\n        var excess = columnWidth - containerWidth % columnWidth;\r\n        // if overshoot is less than a pixel, round up, otherwise floor it\r\n        var mathMethod = excess && excess < 1 ? 'round' : 'floor';\r\n        cols = Math[mathMethod](cols);\r\n        this.cols = Math.max(cols, 1);\r\n    };\r\n\r\n    Masonry.prototype.getContainerWidth = function() {\r\n        // container is parent if fit width\r\n        var isFitWidth = this._getOption('fitWidth');\r\n        var container = isFitWidth ? this.element.parentNode : this.element;\r\n        // check that this.size and size are there\r\n        // IE8 triggers resize on body size change, so they might not be\r\n        //var size = getSize( container );\r\n        //this.containerWidth = size && size.innerWidth;\r\n        this.containerWidth = $(container).width();\r\n    };\r\n\r\n    Masonry.prototype._getItemLayoutPosition = function(item) {\r\n        item.getSize();\r\n        // how many columns does this brick span\r\n        var remainder = item.size.outerWidth % this.columnWidth;\r\n        var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';\r\n        // round if off by 1 pixel, otherwise use ceil\r\n        var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);\r\n        colSpan = Math.min(colSpan, this.cols);\r\n\r\n        var colGroup = this._getColGroup(colSpan);\r\n        // get the minimum Y value from the columns\r\n        var minimumY = Math.min.apply(Math, colGroup);\r\n        var shortColIndex = colGroup.indexOf(minimumY);\r\n\r\n        // position the brick\r\n        var position = {\r\n            x: this.columnWidth * shortColIndex,\r\n            y: minimumY\r\n        };\r\n\r\n        // apply setHeight to necessary columns\r\n        var setHeight = minimumY + item.size.outerHeight;\r\n        var setSpan = this.cols + 1 - colGroup.length;\r\n        for (var i = 0; i < setSpan; i++) {\r\n            this.colYs[shortColIndex + i] = setHeight;\r\n        }\r\n\r\n        return position;\r\n    };\r\n\r\n    /**\r\n     * @param {Number} colSpan - number of columns the element spans\r\n     * @returns {Array} colGroup\r\n     */\r\n    Masonry.prototype._getColGroup = function(colSpan) {\r\n        if (colSpan < 2) {\r\n            // if brick spans only one column, use all the column Ys\r\n            return this.colYs;\r\n        }\r\n\r\n        var colGroup = [];\r\n        // how many different places could this brick fit horizontally\r\n        var groupCount = this.cols + 1 - colSpan;\r\n        // for each group potential horizontal position\r\n        for (var i = 0; i < groupCount; i++) {\r\n            // make an array of colY values for that one group\r\n            var groupColYs = this.colYs.slice(i, i + colSpan);\r\n            // and get the max value of the array\r\n            colGroup[i] = Math.max.apply(Math, groupColYs);\r\n        }\r\n        return colGroup;\r\n    };\r\n\r\n    Masonry.prototype._manageStamp = function(stamp) {\r\n        var stampSize = getSize(stamp);\r\n        var offset = this._getElementOffset(stamp);\r\n        // get the columns that this stamp affects\r\n        var isOriginLeft = this._getOption('originLeft');\r\n        var firstX = isOriginLeft ? offset.left : offset.right;\r\n        var lastX = firstX + stampSize.outerWidth;\r\n        var firstCol = Math.floor(firstX / this.columnWidth);\r\n        firstCol = Math.max(0, firstCol);\r\n        var lastCol = Math.floor(lastX / this.columnWidth);\r\n        // lastCol should not go over if multiple of columnWidth #425\r\n        lastCol -= lastX % this.columnWidth ? 0 : 1;\r\n        lastCol = Math.min(this.cols - 1, lastCol);\r\n        // set colYs to bottom of the stamp\r\n\r\n        var isOriginTop = this._getOption('originTop');\r\n        var stampMaxY = (isOriginTop ? offset.top : offset.bottom) +\r\n            stampSize.outerHeight;\r\n        for (var i = firstCol; i <= lastCol; i++) {\r\n            this.colYs[i] = Math.max(stampMaxY, this.colYs[i]);\r\n        }\r\n    };\r\n\r\n    Masonry.prototype._getContainerSize = function() {\r\n        this.maxY = Math.max.apply(Math, this.colYs);\r\n        var size = {\r\n            height: this.maxY\r\n        };\r\n\r\n        if (this._getOption('fitWidth')) {\r\n            size.width = this._getContainerFitWidth();\r\n        }\r\n\r\n        return size;\r\n    };\r\n\r\n    Masonry.prototype._getContainerFitWidth = function() {\r\n        var unusedCols = 0;\r\n        // count unused columns\r\n        var i = this.cols;\r\n        while (--i) {\r\n            if (this.colYs[i] !== 0) {\r\n                break;\r\n            }\r\n            unusedCols++;\r\n        }\r\n        // fit container to columns that have been used\r\n        return (this.cols - unusedCols) * this.columnWidth - this.gutter;\r\n    };\r\n\r\n    Masonry.prototype.needsResizeLayout = function() {\r\n        var previousWidth = this.containerWidth;\r\n        this.getContainerWidth();\r\n        return previousWidth != this.containerWidth;\r\n    };\r\n\r\n\r\n    //---copy from outlayer\r\n    var proto = Masonry.prototype;\r\n\r\n    // globally unique identifiers\r\n    var GUID = 0;\r\n\r\n    // use element as selector string\r\n    var getQueryElement = function(elem) {\r\n        if (typeof elem == 'string') {\r\n            return document.querySelector(elem);\r\n        }\r\n        return elem;\r\n    };\r\n    // turn element or nodeList into an array\r\n    var makeArray = function(obj) {\r\n        var ary = [];\r\n        if (Array.isArray(obj)) {\r\n            // use object if already an array\r\n            ary = obj;\r\n        } else if (obj && typeof obj.length == 'number') {\r\n            // convert nodeList to array\r\n            for (var i = 0; i < obj.length; i++) {\r\n                ary.push(obj[i]);\r\n            }\r\n        } else {\r\n            // array of single index\r\n            ary.push(obj);\r\n        }\r\n        return ary;\r\n    };\r\n    var indexOf = Array.prototype.indexOf ? function(ary, obj) {\r\n        return ary.indexOf(obj);\r\n    } : function(ary, obj) {\r\n        for (var i = 0, len = ary.length; i < len; i++) {\r\n            if (ary[i] === obj) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    var removeFrom = function(ary, obj) {\r\n        var index = indexOf(ary, obj);\r\n        if (index != -1) {\r\n            ary.splice(index, 1);\r\n        }\r\n    };\r\n\r\n    var filterFindElements = function(elems, selector) {\r\n        // make array of elems\r\n        elems = makeArray(elems);\r\n        var ffElems = [];\r\n\r\n        elems.forEach(function(elem) {\r\n            // check that elem is an actual element\r\n            if (!(elem instanceof HTMLElement)) {\r\n                return;\r\n            }\r\n            // add elem if no selector\r\n            if (!selector) {\r\n                ffElems.push(elem);\r\n                return;\r\n            }\r\n            // filter & find items if we have a selector\r\n            // filter\r\n            //if ( matchesSelector( elem, selector ) ) {\r\n            if (jQuery(elem).is(selector)) {\r\n                ffElems.push(elem);\r\n            }\r\n            // find children\r\n            var childElems = elem.querySelectorAll(selector);\r\n            // concat childElems to filterFound array\r\n            for (var i = 0; i < childElems.length; i++) {\r\n                ffElems.push(childElems[i]);\r\n            }\r\n        });\r\n\r\n        return ffElems;\r\n    };\r\n\r\n    /**\r\n     * set options\r\n     * @param {Object} opts\r\n     */\r\n    proto.option = function(opts) {\r\n        jQuery.extend(this.options, opts);\r\n    };\r\n\r\n    /**\r\n     * get backwards compatible option value, check old name\r\n     */\r\n    proto._getOption = function(option) {\r\n        var oldOption = this.constructor.compatOptions[option];\r\n        return oldOption && this.options[oldOption] !== undefined ?\r\n            this.options[oldOption] : this.options[option];\r\n    };\r\n\r\n    proto._create = function() {\r\n        // get items from children\r\n        this.reloadItems();\r\n        // elements that affect layout, but are not laid out\r\n        //this.stamps = [];\r\n        //this.stamp( this.options.stamp );\r\n        // set container style\r\n        jQuery.extend(this.element.style, this.options.containerStyle);\r\n\r\n        // bind resize method\r\n        //var canBindResize = this._getOption('resize');\r\n        //if ( canBindResize ) {\r\n        //  this.bindResize();\r\n        //}\r\n    };\r\n\r\n    // goes through all children again and gets bricks in proper order\r\n    proto.reloadItems = function() {\r\n        // collection of item elements\r\n        this.items = this._itemize(this.element.children);\r\n    };\r\n\r\n\r\n    /**\r\n     * turn elements into Outlayer.Items to be used in layout\r\n     * @param {Array or NodeList or HTMLElement} elems\r\n     * @returns {Array} items - collection of new Outlayer Items\r\n     */\r\n    proto._itemize = function(elems) {\r\n\r\n        var itemElems = this._filterFindItemElements(elems);\r\n        var Item = this.constructor.Item;\r\n\r\n        // create new Outlayer Items for collection\r\n        var items = [];\r\n        for (var i = 0; i < itemElems.length; i++) {\r\n            var elem = itemElems[i];\r\n            var item = new Item(elem, this);\r\n            items.push(item);\r\n        }\r\n\r\n        return items;\r\n    };\r\n\r\n    /**\r\n     * get item elements to be used in layout\r\n     * @param {Array or NodeList or HTMLElement} elems\r\n     * @returns {Array} items - item elements\r\n     */\r\n    proto._filterFindItemElements = function(elems) {\r\n        //return utils.filterFindElements( elems, this.options.itemSelector );\r\n        //return jQuery(elems).filter(this.options.itemSelector );\r\n        return filterFindElements(elems, this.options.itemSelector);\r\n    };\r\n\r\n\r\n\r\n    /**\r\n     * lays out all items\r\n     */\r\n    proto.layout = function() {\r\n        this._resetLayout();\r\n        //this._manageStamps();\r\n\r\n        // don't animate first layout\r\n        var layoutInstant = this._getOption('layoutInstant');\r\n        var isInstant = layoutInstant !== undefined ?\r\n            layoutInstant : !this._isLayoutInited;\r\n        this.layoutItems(this.items, isInstant);\r\n\r\n        // flag for initalized\r\n        this._isLayoutInited = true;\r\n    };\r\n\r\n    /**\r\n     * get measurement from option, for columnWidth, rowHeight, gutter\r\n     * if option is String -> get element from selector string, & get size of element\r\n     * if option is Element -> get size of element\r\n     * else use option as a number\r\n     *\r\n     * @param {String} measurement\r\n     * @param {String} size - width or height\r\n     * @private\r\n     */\r\n    proto._getMeasurement = function(measurement, size) {\r\n        var option = this.options[measurement];\r\n        var elem;\r\n        if (!option) {\r\n            // default to 0\r\n            this[measurement] = 0;\r\n        } else {\r\n            // use option as an element\r\n            if (typeof option == 'string') {\r\n                elem = this.element.querySelector(option);\r\n            } else if (option instanceof HTMLElement) {\r\n                elem = option;\r\n            }\r\n            // use size of element, if element\r\n            //this[ measurement ] = elem ? getSize( elem )[ size ] : option;\r\n            this[measurement] = elem ? $(elem)[size]() : option;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * layout a collection of item elements\r\n     * @api public\r\n     */\r\n    proto.layoutItems = function(items, isInstant) {\r\n        items = this._getItemsForLayout(items);\r\n\r\n        this._layoutItems(items, isInstant);\r\n\r\n        this._postLayout();\r\n    };\r\n\r\n    /**\r\n     * get the items to be laid out\r\n     * you may want to skip over some items\r\n     * @param {Array} items\r\n     * @returns {Array} items\r\n     */\r\n    proto._getItemsForLayout = function(items) {\r\n        return items.filter(function(item) {\r\n            return !item.isIgnored;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * layout items\r\n     * @param {Array} items\r\n     * @param {Boolean} isInstant\r\n     */\r\n    proto._layoutItems = function(items, isInstant) {\r\n        // this._emitCompleteOnItems( 'layout', items );\r\n\r\n        if (!items || !items.length) {\r\n            // no items, emit event with empty array\r\n            return;\r\n        }\r\n\r\n        var queue = [];\r\n\r\n        items.forEach(function(item) {\r\n            // get x/y object from method\r\n            var position = this._getItemLayoutPosition(item);\r\n            // enqueue\r\n            position.item = item;\r\n            position.isInstant = isInstant || item.isLayoutInstant;\r\n            queue.push(position);\r\n        }, this);\r\n\r\n        this._processLayoutQueue(queue);\r\n    };\r\n\r\n    /**\r\n     * iterate over array and position each item\r\n     * Reason being - separating this logic prevents 'layout invalidation'\r\n     * thx @paul_irish\r\n     * @param {Array} queue\r\n     */\r\n    proto._processLayoutQueue = function(queue) {\r\n        queue.forEach(function(obj) {\r\n            this._positionItem(obj.item, obj.x, obj.y, obj.isInstant);\r\n        }, this);\r\n    };\r\n\r\n    /**\r\n     * Sets position of item in DOM\r\n     * @param {Outlayer.Item} item\r\n     * @param {Number} x - horizontal position\r\n     * @param {Number} y - vertical position\r\n     * @param {Boolean} isInstant - disables transitions\r\n     */\r\n    proto._positionItem = function(item, x, y, isInstant) {\r\n        if (isInstant) {\r\n            // if not transition, just set CSS\r\n            item.goTo(x, y);\r\n        } else {\r\n            item.moveTo(x, y);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Any logic you want to do after each layout,\r\n     * i.e. size the container\r\n     */\r\n    proto._postLayout = function() {\r\n        this.resizeContainer();\r\n    };\r\n\r\n    proto.resizeContainer = function() {\r\n        var isResizingContainer = this._getOption('resizeContainer');\r\n        if (!isResizingContainer) {\r\n            return;\r\n        }\r\n        var size = this._getContainerSize();\r\n        if (size) {\r\n            this._setContainerMeasure(size.width, true);\r\n            this._setContainerMeasure(size.height, false);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @param {Number} measure - size of width or height\r\n     * @param {Boolean} isWidth\r\n     */\r\n    proto._setContainerMeasure = function(measure, isWidth) {\r\n        if (measure === undefined) {\r\n            return;\r\n        }\r\n\r\n        var elemSize = this.size;\r\n        // add padding and border width if border box\r\n        if (elemSize.isBorderBox) {\r\n            measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight +\r\n                elemSize.borderLeftWidth + elemSize.borderRightWidth :\r\n                elemSize.paddingBottom + elemSize.paddingTop +\r\n                elemSize.borderTopWidth + elemSize.borderBottomWidth;\r\n        }\r\n\r\n        measure = Math.max(measure, 0);\r\n        this.element.style[isWidth ? 'width' : 'height'] = measure + 'px';\r\n    };\r\n\r\n\r\n\r\n    /**\r\n     * add items to Outlayer instance\r\n     * @param {Array or NodeList or Element} elems\r\n     * @returns {Array} items - Outlayer.Items\r\n     **/\r\n    proto.addItems = function(elems) {\r\n        var items = this._itemize(elems);\r\n        // add items to collection\r\n        if (items.length) {\r\n            this.items = this.items.concat(items);\r\n        }\r\n        return items;\r\n    };\r\n\r\n    /**\r\n     * Layout newly-appended item elements\r\n     * @param {Array or NodeList or Element} elems\r\n     */\r\n    proto.appended = function(elems) {\r\n        var items = this.addItems(elems);\r\n        if (!items.length) {\r\n            return;\r\n        }\r\n        // layout and reveal just the new items\r\n        this.layoutItems(items, true);\r\n        this.reveal(items);\r\n    };\r\n\r\n    /**\r\n     * Layout prepended elements\r\n     * @param {Array or NodeList or Element} elems\r\n     */\r\n    proto.prepended = function(elems) {\r\n        var items = this._itemize(elems);\r\n        if (!items.length) {\r\n            return;\r\n        }\r\n        // add items to beginning of collection\r\n        var previousItems = this.items.slice(0);\r\n        this.items = items.concat(previousItems);\r\n        // start new layout\r\n        this._resetLayout();\r\n        //this._manageStamps();\r\n        // layout new stuff without transition\r\n        this.layoutItems(items, true);\r\n        this.reveal(items);\r\n        // layout previous items\r\n        this.layoutItems(previousItems);\r\n    };\r\n\r\n    /**\r\n     * reveal a collection of items\r\n     * @param {Array of Outlayer.Items} items\r\n     */\r\n    proto.reveal = function(items) {\r\n        // this._emitCompleteOnItems( 'reveal', items );\r\n        if (!items || !items.length) {\r\n            return;\r\n        }\r\n        items.forEach(function(item) {\r\n            //item.reveal();\r\n        });\r\n    };\r\n\r\n    /**\r\n     * hide a collection of items\r\n     * @param {Array of Outlayer.Items} items\r\n     */\r\n    proto.hide = function(items) {\r\n        // this._emitCompleteOnItems( 'hide', items );\r\n        if (!items || !items.length) {\r\n            return;\r\n        }\r\n        items.forEach(function(item) {\r\n            item.hide();\r\n        });\r\n    };\r\n\r\n    /**\r\n     * reveal item elements\r\n     * @param {Array}, {Element}, {NodeList} items\r\n     */\r\n    proto.revealItemElements = function(elems) {\r\n        var items = this.getItems(elems);\r\n        this.reveal(items);\r\n    };\r\n\r\n    /**\r\n     * hide item elements\r\n     * @param {Array}, {Element}, {NodeList} items\r\n     */\r\n    proto.hideItemElements = function(elems) {\r\n        var items = this.getItems(elems);\r\n        this.hide(items);\r\n    };\r\n\r\n    /**\r\n     * get Outlayer.Item, given an Element\r\n     * @param {Element} elem\r\n     * @param {Function} callback\r\n     * @returns {Outlayer.Item} item\r\n     */\r\n    proto.getItem = function(elem) {\r\n        // loop through items to get the one that matches\r\n        for (var i = 0; i < this.items.length; i++) {\r\n            var item = this.items[i];\r\n            if (item.element == elem) {\r\n                // return item\r\n                return item;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * get collection of Outlayer.Items, given Elements\r\n     * @param {Array} elems\r\n     * @returns {Array} items - Outlayer.Items\r\n     */\r\n    proto.getItems = function(elems) {\r\n        elems = makeArray(elems);\r\n        var items = [];\r\n        elems.forEach(function(elem) {\r\n            var item = this.getItem(elem);\r\n            if (item) {\r\n                items.push(item);\r\n            }\r\n        }, this);\r\n\r\n        return items;\r\n    };\r\n\r\n    /**\r\n     * remove element(s) from instance and DOM\r\n     * @param {Array or NodeList or Element} elems\r\n     */\r\n    proto.remove = function(elems) {\r\n        var removeItems = this.getItems(elems);\r\n\r\n        // this._emitCompleteOnItems('remove', removeItems);\r\n\r\n        // bail if no items to remove\r\n        if (!removeItems || !removeItems.length) {\r\n            return;\r\n        }\r\n\r\n        removeItems.forEach(function(item) {\r\n            if(item.element) item.element.remove();\r\n            // remove item from collection\r\n            removeFrom(this.items, item);\r\n        }, this);\r\n    };\r\n\r\n    return skylark.attach(\"intg.Masonry\", Masonry);\r\n});\r\n\ndefine('skylark-masonry/main',[\r\n\t\"./Masonry\"\r\n],function(Masonry){\r\n\treturn Masonry;\r\n});\ndefine('skylark-masonry', ['skylark-masonry/main'], function (main) { return main; });\n\n"]}